#!/bin/bash
# Copyright (c) 2019 by Audere
#
# Use of this source code is governed by an MIT-style license that
# can be found in the LICENSE file distributed with this file.

set -euo pipefail
umask 077
SELF_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"
. "$SELF_DIR/util.sh"

ACCOUNT="$(aws sts get-caller-identity --output text --query 'Account')"
REGISTRY="$ACCOUNT.dkr.ecr.us-west-2.amazonaws.com"
RED='\033[0;31m'
NC='\033[0m' # No Color

function fail() {
  circle_url=${CIRCLE_BUILD_URL:-N/A}
  curl -X POST --data-urlencode "payload={\"text\": \"Deploy FAILED\nCircle Build URL: $circle_url\", \"icon_emoji\": \":interrobang:\"}" $INFRA_SLACK_WEBHOOK
  echo 1>&2 -e "$*"
  exit 1
}

function ecr_login() {
  echo "=================================================="
  echo "Logging in to ECR"
  use_token=${ECR_NO_TOKEN:-false}
  if [[ $use_token == true ]]; then
    $(aws ecr get-login --no-include-email)
  else
    "$SELF_DIR/ecr-login"
  fi
}

function ecr_publish() {
  local repo="$1"
  local tag="${2}"

  echo "=================================================="
  echo "Finding local image"
  docker image inspect "$repo:$tag" | jq --raw-output '.[].RepoTags | .[]'

  echo "=================================================="
  echo "Ensuring the destination repo for $repo exists"
  if [[ -z "$(aws ecr describe-repositories | jq '.repositories | .[] | select(.repositoryName == "'"${repo}"'")')" ]]; then
    echo "Creating new repo"
    aws ecr create-repository --repository-name "$repo"
  fi
  echo "Tagging '$repo' for upload to ECR"
  docker tag "$repo:$tag" "$REGISTRY/$repo:$tag"
  echo "Pushing '$repo' to ECR"
  docker push "$REGISTRY/$repo:$tag"
}

function ecs_deploy() {
  local service_id="$1"
  local service="$2"
  local repo_lines="$3"
  local default_tag="$4"
  local new_tag="$5"

  shift
  shift
  shift
  shift
  shift

  local repos=()
  while read -r line; do
    repos+=("$line")
  done <<< "$repo_lines"

  echo "=================================================="
  for repo in "${repos[@]}"; do
    local current_tag="$default_tag"

    # Check for specific tags passed in the the form repo:tag
    if [ $# -ne 0 ]; then
      local current_tags=("$@")
      for tag in "${current_tags[@]}"; do
        if [[ $tag =~ ^$repo: ]]; then
          current_tag="$(cut -d':' -f2 <<<$tag)"
        fi
      done
    fi

    local current_digest="$(ecr_image_digest "$repo" "$current_tag")"
    if [[ -z "$current_digest" ]]; then
      fail "$repo:$current_tag does not have a valid manifest - did you forget to publish?"
    fi

    local existing_digest="$(ecr_image_digest "$repo" "$new_tag")"
    if [[ -n "$existing_digest" && "$existing_digest" == "$current_digest" ]]; then
      echo "The image for '$repo:$new_tag' in ECR already matches '$repo:$current_tag', skipping update."
    else
      echo "Tagging '$repo:$current_tag' as '$repo:$new_tag'"
      local manifest="$(ecr_image_manifest "$repo" "$current_tag")"
      aws ecr put-image --repository-name "$repo" --image-tag "$new_tag" --image-manifest "$manifest"
    fi
  done

  local cluster="$(config_get "cluster.$new_tag")"
  local oldTaskID="$(get_current_running_task "$cluster" "$service_id")"
  echo "Task ID of '$service_id' prior to update is '$oldTaskID'"

  echo "Updating ECS service - '$service_id'"
  aws ecs update-service --cluster "$cluster" --service "$service_id" --force-new-deployment
   
  local count=1
  RETRY_INTERVAL=6
  MAX_RETRIES=50
  while [[ $count -le $MAX_RETRIES ]]; do
    sleep $RETRY_INTERVAL
    local currentTask="$(get_current_running_task "$cluster" "$service_id")"
    if [[ "$currentTask" != "$oldTaskID" ]]; then 
      echo "Deploy of update successful"
      echo "New task ID of '$service_id' is '$currentTask'"
      break
    else
      echo "Waited $(($RETRY_INTERVAL * $count)) seconds for new task to start..."
      (( count++ )) 
    fi
  done

  if [[ $count -gt $MAX_RETRIES ]]; then 
    fail "${RED}ERROR:${NC} New task not deployed after $(($RETRY_INTERVAL * $MAX_RETRIES)) seconds"
  else 
    test_script="$(config_get "\"$service\".\"test\"")"
    if [[ -n "$test_script" ]]; then 
      echo "Running post-deploy test script $test_script"
      if ! "$SELF_DIR/$test_script" "$new_tag" ; then 
        fail "${RED}ERROR:${NC} Newly deployed $service failed post-deploy tests, possibly needs rollback!!"
      fi
    fi
  fi
}

function ecr_query_image() {
  local subpath="$1"
  local repo="$2"
  local tag="$3"
  aws ecr batch-get-image --repository-name "$repo" --image-ids "imageTag=$tag" --query "images[].$subpath" --output text
}
function ecr_image_digest()   { ecr_query_image "imageId.imageDigest" "$@"; }
function ecr_image_manifest() { ecr_query_image "imageManifest" "$@"; }

function check_service() {
  local service="$1"

  [[ -n "$(config_get "\"$service\"")" ]] \
    || fail "Expected a defined service, got '$service'."
}

function get_current_running_task() {
  local cluster="$1"
  local service="$2"
  local all_tasks="$(aws ecs list-tasks --cluster "$cluster" --service-name "$service" | jq -r '.taskArns|.[]')"
  for task in ${all_tasks}; do 
    local status="$(aws ecs describe-tasks --cluster "$cluster" --tasks "$task" | jq -r '.tasks[0].lastStatus')"
    if [[ "$status" == "RUNNING" ]]; then 
      echo "$task"
      return 0
    fi
  done
  # Didn't find any running tasks
  return 1  
}

function config_get() {
  jqraw ".$1 // empty" "$SELF_DIR/service-registry.json"
}

function config_get_list() {
  jqraw -c ".$1[]" "$SELF_DIR/service-registry.json"
}

function default_commit() {
  cd "$SELF_DIR"
  git rev-parse HEAD
}

subcommand="$1"
shift
case "$subcommand" in
  publish)
    repo="$1"
    tag="${2:-latest}"

    username=${CIRCLE_USERNAME:-$(whoami)}
    curl -X POST --data-urlencode "payload={\"text\": \"$username is deploying $repo $tag\", \"icon_emoji\": \":large_blue_circle:\"}" $INFRA_SLACK_WEBHOOK
    ecr_login
    ecr_publish "$repo" "$tag"

    echo "=================================================="
    echo "Published '$repo:$tag' to ECR"
    echo "=================================================="
    ;;

  stage | prod)
    service="$1"
    shift

    check_service $service
    repos="$(config_get_list "\"$service\".repo")"
    echo "Repos: '$repos'"

    case "$subcommand" in
      stage) default_tag="latest"; new_tag="staging";;
      prod)  default_tag="staging"; new_tag="prod";;
      *) fail "internal error '$subcommand'";;
    esac

    service_id="$(config_get "\"$service\".\"${new_tag}_service\"")"
    echo "Service ID: '$service_id'"

    ecr_login
    ecs_deploy "$service_id" "$service" "$repos" "$default_tag" "$new_tag" "$@"

    commit = $(default_commit)
    curl -X POST --data-urlencode "payload={\"text\": \"Deploy succeeded!\nService: $service\nCommit: $commit\", \"icon_emoji\": \":large_blue_circle:\"}" $INFRA_SLACK_WEBHOOK
    echo "=================================================="
    echo "Deployed '${service_id}'"
    echo "=================================================="
    ;;

  *)
    fail "Unrecognized sub-command '$subcommand'"
    ;;
esac
